---
title: "Preprocessing access layers"
output: html_document
---

This R file creates a 100x100 'access score' raster layer that is loaded into the app to speed up nudge generation.

It does it by working through 10km grid squares


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#load packages
library(osmdata)
library(sf)
library(leaflet)
library(raster)
library(rgdal)
library(dplyr)
```

Load UK 10k grids and 100x100 raster

```{r}
uk_grid <- st_read('/data/data/DECIDE_constraintlayers/raw_data/UK_grids/uk_grid_10km.shp')
st_crs(uk_grid) <- 27700

# sanity check that the grid squares look like the UK
plot(st_geometry(uk_grid), add = F, col = 'orange')

uk_grid[1,]


#
raster100 <- raster::stack('/data/data/DECIDE_constraintlayers/environmental_data/100mRastOneLayer.grd')
plot(raster100)

raster100_df <- as.data.frame(raster100, xy=T, centroids=TRUE)[,1:2]

```



```{r}

#loop through all of the UK 10k grid squares
for (i in 1:nrow(uk_grid)){
  
  ### Getting OSM data
  
  #make the bounding box for the OSM query
  this_10k_grid <- uk_grid[i,]$geometry #get the 10kgrid
  this_10k_gridWGS84 <- st_transform(this_10k_grid, 4326) # convert to WGS84
  
  # build the OSM query
  q1 <- opq(bbox = this_10k_gridWGS84) %>%
    add_osm_feature(key = 'highway', value = 'footway') %>% #footways
    add_osm_feature(key = 'highway', value = 'bridleway') %>% # bridleways
    add_osm_feature(key = 'highway', value = 'steps') %>% # steps (basically footpaths)
    add_osm_feature(key = 'highway', value = 'path') %>% # generic paths
    #add_osm_feature(key = 'highway', value = 'track') %>% # gravel tracks etc Excluded becase often private tracks are included
    add_osm_feature(key = 'highway', value = 'residential') %>% # roads with housing so presumably will be accessible
    add_osm_feature(key = 'highway', value = 'unclassified') %>% #really small roads roads (not actually 'unclassified')
    add_osm_feature(key = 'highway', value = 'tertiary') %>% # roads smaller than b roads etc.
    add_osm_feature(key = 'highway', value = 'cycleway') %>% # some routes are only classified as cycle ways but they are probably accessible on foot - MAYBE
    add_osm_feature(key = 'footway', value = 'sidewalk') %>% # pavements if classified separately to roads
    add_osm_feature(key = 'sidewalk', value = 'both') %>% #roads with pavements 
    add_osm_feature(key = 'sidewalk', value = 'left') %>% #roads with pavements
    add_osm_feature(key = 'sidewalk', value = 'right') #roads with pavements
  
  q2 <- opq(bbox = this_10k_gridWGS84) %>%
    add_osm_feature(key = 'landuse', value = 'military') %>%
    add_osm_feature(key = 'landuse', value = 'quarry') %>%
    add_osm_feature(key = 'aeroway', value = 'aerodrome') %>%
    add_osm_feature(key = 'railway', value = 'rail') %>%
    add_osm_feature(key = 'highway', value = 'motorway') %>%
    add_osm_feature(key = 'highway', value = 'trunk') %>%
    # add_osm_feature(key = 'natural', value = 'water') %>%
    # add_osm_feature(key = 'waterway', value = 'river') %>%
    add_osm_feature(key = 'landuse', value = 'landfill')
  
  #get OSM data
  q1$prefix <- q2$prefix <- "[out:xml][timeout:10000];\n(\n"
  good_features_data <- osmdata_sf(q1)
  bad_features_data <- osmdata_sf(q2)
  
  ### Getting PROW, Access land etc. data
  
  crow <- st_read("/data/data/DECIDE_constraintlayers/raw_data/CRoW_Act_2000_-_Access_Layer_(England)-shp/gridded_data_10km/access_land_gridnumber_1500.shp", quiet = TRUE) %>% st_transform(4326)
  prow <- st_read("/data/data/DECIDE_constraintlayers/raw_data/rowmaps_footpathbridleway/rowmaps_footpathbridleway/gridded_data_10km/prow_gridnumber_1500.shp", quiet = TRUE) %>% st_transform(4326)
  
  
  
  
  
  
  # get the bounding box of the 10km grid square
  grid_bb <- st_bbox(this_10k_grid)
  
  #only select the raster squares in the 10km grid square
  raster_this_grid <- raster100_df %>% filter(x > grid_bb$xmin,
                                              x < grid_bb$xmax,
                                              y > grid_bb$ymin,
                                              y < grid_bb$ymax)
  
  #get the easting and northing projection
  projcrs <- crs(this_10k_grid)
  
  # make the raster df into a sd object using the projection but transform it to WGS84 for these operations
  raster_as_sf <- st_as_sf(raster_this_grid,coords = c("x", "y"),crs = projcrs) %>% st_transform(4326)
  
  #see if the grid squares are within each of the good features
  distance_check_good <- 
    rowSums(st_is_within_distance(raster_as_sf,good_features_data$osm_lines,dist = 100,sparse = FALSE)) +
    rowSums(st_is_within_distance(raster_as_sf,prow$geometry,dist = 100,sparse = FALSE)) +
    rowSums(st_is_within_distance(raster_as_sf,crow$geometry,dist = 100,sparse = FALSE))
  
  # do the same for the bad features
  distance_check_bad <- rowSums(st_is_within_distance(raster_as_sf,bad_features_data$osm_lines,dist = 50,sparse = FALSE)) + rowSums(st_is_within_distance(raster_as_sf,bad_features_data$osm_polygons,dist = 25,sparse = FALSE))
  
  raster_as_sf$access <- distance_check_good
  raster_as_sf$no_go <- distance_check_bad
  
  
  
  # View this  on a leaflet map
  m <- leaflet() %>%
    addTiles() %>%
    addPolylines(data=good_features_data$osm_line,opacity=1,weight=2) %>%
    addPolygons(data=this_10k_gridWGS84,opacity=1,fillOpacity = 0,weight=2,color = "black") %>%
    addCircles(data = raster_as_sf %>% filter(access>0),radius = 50,weight=0) %>%
    addCircles(data = raster_as_sf %>% filter(no_go>0),radius = 50,weight=0,color = "red") %>%
    addPolygons(data = crow$geometry) %>%
    addPolylines(data = prow$geometry,opacity=1,weight=2)
  
  m
  

  
  #loop through each of the 100x100m grid squares
  
  
  
  
  
  
}











# rebuild the raste
rasterFromXYZ(r_df)





```














































function to get bounding box +5km (approx)

```{r}

get_bb_5km <- function(latitude,longitude){
  
  meters = 5000

# // number of km per degree = ~111km (111.32 in google maps, but range varies
#    between 110.567km at the equator and 111.699km at the poles)
# // 1km in degree = 1 / 111.32km = 0.0089
# // 1m in degree = 0.0089 / 1000 = 0.0000089
  coef <- meters * 0.0000089

  new_lat1 <- latitude - coef
  new_lat2 <- latitude + coef
  
  #// pi / 180 = 0.018
  new_long1 <- longitude - coef / cos(latitude * 0.018)
  new_long2 <- longitude + coef / cos(latitude * 0.018)
  
  bb <- data.frame(min = c(new_long1,new_lat1), max = c(new_long2,new_lat2))

  row.names(bb) <- c("x","y")
  
  bb %>% as.matrix()
}

test <- get_bb_5km(53.2,-1.5)

test


```

```{r}

# manually specify a bounding box
# coordinates from https://gist.github.com/graydon/11198540
#bb <- getbb ('Sheffield, UK')
bb <- get_bb_5km(53.2,-1.5)

#bb <- get_bb_5km(52.36553758871974, -1.4741498217780282)

#might want to break these queries down a bit?

# build a query for all sorts of accessible paths and roads
q1 <- opq(bbox = bb) %>%
  add_osm_feature(key = 'highway', value = 'footway') %>% #footways
  add_osm_feature(key = 'highway', value = 'bridleway') %>% # bridleways
  add_osm_feature(key = 'highway', value = 'steps') %>% # steps (basically footpaths)
  add_osm_feature(key = 'highway', value = 'path') %>% # generic paths
  #add_osm_feature(key = 'highway', value = 'track') %>% # gravel tracks etc - possibly private? MAYBE
  add_osm_feature(key = 'highway', value = 'residential') %>% # roads with housing so presumably will be accessible
  add_osm_feature(key = 'highway', value = 'unclassified') %>% #really small roads roads (not actually 'unclassified')
  add_osm_feature(key = 'highway', value = 'tertiary') %>% # roads smaller than b roads etc.
  add_osm_feature(key = 'highway', value = 'cycleway') %>% # some routes are only classified as cycle ways but they are probably accessible on foot - MAYBE
  add_osm_feature(key = 'footway', value = 'sidewalk') %>% # pavements if classified separately to roads
  add_osm_feature(key = 'sidewalk', value = 'both') %>% #roads with pavements 
  add_osm_feature(key = 'sidewalk', value = 'left') %>% #roads with pavements
  add_osm_feature(key = 'sidewalk', value = 'right') #roads with pavements

q2 <- opq(bbox = bb) %>%
  add_osm_feature(key = 'landuse', value = 'military') %>%
  add_osm_feature(key = 'landuse', value = 'quarry') %>%
  add_osm_feature(key = 'aeroway', value = 'aerodrome') %>%
  add_osm_feature(key = 'railway', value = 'rail') %>%
  add_osm_feature(key = 'highway', value = 'motorway') %>%
  add_osm_feature(key = 'highway', value = 'trunk') %>%
  # add_osm_feature(key = 'natural', value = 'water') %>%
  # add_osm_feature(key = 'waterway', value = 'river') %>%
  add_osm_feature(key = 'landuse', value = 'landfill')

#change the timeout
q1$prefix <- q2$prefix <- "[out:xml][timeout:10000];\n(\n"

#do the queries
good_features_data <- osmdata_sf(q1)
bad_features_data <- osmdata_sf(q2)

#buffered <- footway_data$osm_lines %>%
#st_buffer(dist=100, endCapStyle="ROUND")

# plot on a leaflet map
m <- leaflet() %>%
  addTiles() %>%
  addPolylines(data=good_features_data$osm_line,opacity=1,weight=2) %>%
  addPolygons(data=bad_features_data$osm_polygons,opacity=0.5,weight=2,color = "red") %>%
  addPolylines(data=bad_features_data$osm_lines,opacity=1,weight=2,color = "red")

m


```


